#!/usr/bin/env node
/**
 * embed-rom.js
 * Reads files from resources/ and generates src/os/fs/romfs.ts as a
 * compile-time read-only virtual filesystem (RomFS) embedded in the JS bundle.
 *
 * Run via: npm run embed:rom
 *
 * Currently embedded files:
 *   resources/bible.txt  →  /rom/bible.txt  (King James Bible, public domain)
 */

const fs   = require('fs');
const path = require('path');

const RESOURCES_DIR = path.join(__dirname, '..', 'resources');
const OUTPUT        = path.join(__dirname, '..', 'src', 'os', 'fs', 'romfs.ts');

// Map of  virtualPath → local filename inside resources/
const ROM_MANIFEST = [
  { virtual: '/rom/bible.txt', file: 'bible.txt' },
];

console.log('Generating ROM filesystem (romfs.ts)...');

const embeddings = [];
for (const entry of ROM_MANIFEST) {
  const localPath = path.join(RESOURCES_DIR, entry.file);
  if (!fs.existsSync(localPath)) {
    console.warn(`  (skip) ${entry.file} not found in resources/ — romfs will be empty for this entry`);
    continue;
  }
  const raw = fs.readFileSync(localPath, 'utf8');
  // Normalise CRLF → LF, then escape for a template literal
  const content = raw
    .replace(/\r\n/g, '\n')
    .replace(/\\/g,  '\\\\')
    .replace(/`/g,   '\\`')
    .replace(/\$\{/g, '\\${');
  embeddings.push({ virtual: entry.virtual, content });
  console.log(`  + ${entry.virtual}  (${(raw.length / 1024).toFixed(1)} KB)`);
}

// Build the record literal
const recordLines = embeddings.map(e =>
  `  '${e.virtual}': \`${e.content}\``
).join(',\n\n');

const ts = `/**
 * JSOS ROM Filesystem — auto-generated by scripts/embed-rom.js
 *
 * DO NOT EDIT.  Regenerate with:  npm run embed:rom
 *
 * Provides read-only virtual files embedded directly in the JS bundle.
 * Mounted at /rom by main.ts:
 *
 *   fs.readFile('/rom/bible.txt')  // King James Bible
 */
import type { VFSMount, FileType } from './filesystem.js';

// ── Embedded file contents ─────────────────────────────────────────────────
const romData: Record<string, string> = {
${recordLines}
};

// ── RomFS VFSMount implementation ──────────────────────────────────────────
export class RomFS implements VFSMount {
  read(path: string): string | null {
    return Object.prototype.hasOwnProperty.call(romData, path)
      ? romData[path]
      : null;
  }

  list(dirPath: string): Array<{ name: string; type: FileType; size: number }> {
    var out: Array<{ name: string; type: FileType; size: number }> = [];
    var prefix = dirPath.endsWith('/') ? dirPath : dirPath + '/';
    for (var p in romData) {
      if (!Object.prototype.hasOwnProperty.call(romData, p)) continue;
      if (p.indexOf(prefix) === 0) {
        var rest = p.slice(prefix.length);
        // Direct children only (no slash in remaining path segment)
        if (rest.length > 0 && rest.indexOf('/') === -1) {
          out.push({ name: rest, type: 'file' as FileType, size: romData[p].length });
        }
      }
    }
    return out;
  }

  exists(path: string): boolean {
    if (Object.prototype.hasOwnProperty.call(romData, path)) return true;
    // Check directory existence
    var prefix = path.endsWith('/') ? path : path + '/';
    for (var p in romData) {
      if (Object.prototype.hasOwnProperty.call(romData, p) && p.indexOf(prefix) === 0) return true;
    }
    return false;
  }

  isDirectory(path: string): boolean {
    if (Object.prototype.hasOwnProperty.call(romData, path)) return false;
    var prefix = path.endsWith('/') ? path : path + '/';
    for (var p in romData) {
      if (Object.prototype.hasOwnProperty.call(romData, p) && p.indexOf(prefix) === 0) return true;
    }
    return false;
  }
}

export const romFS = new RomFS();
`;

fs.writeFileSync(OUTPUT, ts, 'utf8');
const kb = (fs.statSync(OUTPUT).size / 1024).toFixed(1);
console.log(`Done. ${OUTPUT} written (${kb} KB, ${embeddings.length} file(s) embedded).`);
