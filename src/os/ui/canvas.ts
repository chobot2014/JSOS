/**
 * JSOS Canvas — Phase 3 pixel rendering
 *
 * Maintains a 32-bit BGRA pixel buffer in a JS Uint32Array.
 * flip() transfers the buffer to the physical framebuffer via kernel.fbBlit().
 *
 * Colors are 32-bit values: 0xAARRGGBB (alpha unused by fbBlit — fully opaque).
 * Internally stored as BGRA (matching x86 little-endian framebuffer layout):
 *   0xAARRGGBB → stored as 0xBBGGRRAA in memory.
 * We keep everything as 0xAARRGGBB in the API and convert on blit.
 */

declare var kernel: import('../core/kernel.js').KernelAPI;

export type PixelColor = number; // 0xAARRGGBB

// ── Color constants ────────────────────────────────────────────────────────

export const Colors = {
  BLACK:       0xFF000000,
  WHITE:       0xFFFFFFFF,
  RED:         0xFFFF0000,
  LIGHT_RED:   0xFFFF4444,
  GREEN:       0xFF00FF00,
  LIGHT_GREEN: 0xFF44FF44,
  BLUE:        0xFF0000FF,
  CYAN:        0xFF00FFFF,
  LIGHT_CYAN:  0xFF44FFFF,
  MAGENTA:     0xFFFF00FF,
  YELLOW:      0xFFFFFF00,
  DARK_GREY:   0xFF333333,
  LIGHT_GREY:  0xFFAAAAAA,
  ORANGE:      0xFFFF8800,
  DARK_BLUE:   0xFF000080,
  DARK_GREEN:  0xFF008000,
  TITLE_BG:    0xFF1A3A5C,
  DESKTOP_BG:  0xFF2D4F6B,
  TASKBAR_BG:  0xFF1A2B3C,
  TRANSPARENT: 0x00000000,
};

// ── Bitmap Font (8×8, CP437 printable ASCII) ───────────────────────────────
//
// 95 characters, ASCII 0x20 (space) through 0x7E (~).
// Each character is 8 bytes; each byte is one row, MSB = leftmost pixel.
// Font data derived from the public-domain IBM PC 8×8 CGA ROM glyph set.

/* eslint-disable */
const FONT_DATA_8x8 = new Uint8Array([
  // 0x20 space
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  // 0x21 !
  0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x00,
  // 0x22 "
  0x6C,0x6C,0x24,0x00,0x00,0x00,0x00,0x00,
  // 0x23 #
  0x28,0xFE,0x28,0x28,0xFE,0x28,0x28,0x00,
  // 0x24 $
  0x10,0x7C,0xD0,0x7C,0x16,0x7C,0x10,0x00,
  // 0x25 %
  0x60,0x66,0x0C,0x18,0x30,0x66,0x06,0x00,
  // 0x26 &
  0x38,0x4C,0x38,0x76,0x4C,0x46,0x3B,0x00,
  // 0x27 '
  0x18,0x18,0x10,0x00,0x00,0x00,0x00,0x00,
  // 0x28 (
  0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00,
  // 0x29 )
  0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00,
  // 0x2A *
  0x00,0x24,0x18,0xFF,0x18,0x24,0x00,0x00,
  // 0x2B +
  0x00,0x10,0x10,0x7C,0x10,0x10,0x00,0x00,
  // 0x2C ,
  0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30,
  // 0x2D -
  0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,
  // 0x2E .
  0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,
  // 0x2F /
  0x02,0x06,0x0C,0x18,0x30,0x60,0x40,0x00,
  // 0x30 0
  0x3C,0x46,0x4E,0x56,0x62,0x62,0x3C,0x00,
  // 0x31 1
  0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00,
  // 0x32 2
  0x3C,0x66,0x06,0x1C,0x30,0x66,0x7E,0x00,
  // 0x33 3
  0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00,
  // 0x34 4
  0x0E,0x1E,0x36,0x66,0x7F,0x06,0x06,0x00,
  // 0x35 5
  0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00,
  // 0x36 6
  0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00,
  // 0x37 7
  0x7E,0x66,0x0C,0x18,0x18,0x18,0x18,0x00,
  // 0x38 8
  0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00,
  // 0x39 9
  0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00,
  // 0x3A :
  0x00,0x18,0x18,0x00,0x18,0x18,0x00,0x00,
  // 0x3B ;
  0x00,0x18,0x18,0x00,0x18,0x18,0x30,0x00,
  // 0x3C <
  0x06,0x0C,0x18,0x30,0x18,0x0C,0x06,0x00,
  // 0x3D =
  0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00,
  // 0x3E >
  0x60,0x30,0x18,0x0C,0x18,0x30,0x60,0x00,
  // 0x3F ?
  0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00,
  // 0x40 @
  0x3E,0x61,0x6D,0x6B,0x6E,0x60,0x3E,0x00,
  // 0x41 A
  0x3C,0x66,0x66,0x7E,0x66,0x66,0x66,0x00,
  // 0x42 B
  0x7C,0x66,0x66,0x7C,0x66,0x66,0x7C,0x00,
  // 0x43 C
  0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00,
  // 0x44 D
  0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00,
  // 0x45 E
  0x7E,0x60,0x60,0x7C,0x60,0x60,0x7E,0x00,
  // 0x46 F
  0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x00,
  // 0x47 G
  0x3C,0x66,0x60,0x6E,0x66,0x66,0x3C,0x00,
  // 0x48 H
  0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00,
  // 0x49 I
  0x7E,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,
  // 0x4A J
  0x1E,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,
  // 0x4B K
  0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00,
  // 0x4C L
  0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00,
  // 0x4D M
  0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x00,
  // 0x4E N
  0x63,0x73,0x7B,0x6F,0x67,0x63,0x63,0x00,
  // 0x4F O
  0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,
  // 0x50 P
  0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00,
  // 0x51 Q
  0x3C,0x66,0x66,0x66,0x6A,0x64,0x3A,0x00,
  // 0x52 R
  0x7C,0x66,0x66,0x7C,0x6C,0x66,0x66,0x00,
  // 0x53 S
  0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00,
  // 0x54 T
  0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00,
  // 0x55 U
  0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,
  // 0x56 V
  0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00,
  // 0x57 W
  0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00,
  // 0x58 X
  0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00,
  // 0x59 Y
  0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00,
  // 0x5A Z
  0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00,
  // 0x5B [
  0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,
  // 0x5C backslash
  0x40,0x60,0x30,0x18,0x0C,0x06,0x02,0x00,
  // 0x5D ]
  0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,
  // 0x5E ^
  0x10,0x38,0x6C,0x00,0x00,0x00,0x00,0x00,
  // 0x5F _
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
  // 0x60 `
  0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,
  // 0x61 a
  0x00,0x00,0x3C,0x06,0x3E,0x66,0x3B,0x00,
  // 0x62 b
  0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00,
  // 0x63 c
  0x00,0x00,0x3C,0x60,0x60,0x60,0x3C,0x00,
  // 0x64 d
  0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00,
  // 0x65 e
  0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00,
  // 0x66 f
  0x1C,0x30,0x7C,0x30,0x30,0x30,0x30,0x00,
  // 0x67 g
  0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x3C,
  // 0x68 h
  0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00,
  // 0x69 i
  0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00,
  // 0x6A j
  0x06,0x00,0x1E,0x06,0x06,0x66,0x66,0x3C,
  // 0x6B k
  0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0x00,
  // 0x6C l
  0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,
  // 0x6D m
  0x00,0x00,0x36,0x7F,0x6B,0x63,0x63,0x00,
  // 0x6E n
  0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00,
  // 0x6F o
  0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00,
  // 0x70 p
  0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60,
  // 0x71 q
  0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06,
  // 0x72 r
  0x00,0x00,0x6C,0x76,0x60,0x60,0x60,0x00,
  // 0x73 s
  0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00,
  // 0x74 t
  0x30,0x30,0x7C,0x30,0x30,0x36,0x1C,0x00,
  // 0x75 u
  0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00,
  // 0x76 v
  0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00,
  // 0x77 w
  0x00,0x00,0x63,0x6B,0x7F,0x36,0x22,0x00,
  // 0x78 x
  0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00,
  // 0x79 y
  0x00,0x00,0x66,0x66,0x3E,0x06,0x6C,0x38,
  // 0x7A z
  0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00,
  // 0x7B {
  0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00,
  // 0x7C |
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,
  // 0x7D }
  0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00,
  // 0x7E ~
  0x00,0x32,0x4C,0x00,0x00,0x00,0x00,0x00,
]);
/* eslint-enable */

export class BitmapFont {
  readonly charWidth  = 8;
  readonly charHeight = 8;

  /** True pixel count for measuring text */
  measureText(text: string): { width: number; height: number } {
    return { width: text.length * this.charWidth, height: this.charHeight };
  }

  /**
   * Render a single character into a Canvas.
   * Pixels with bit set are drawn in `color`; others are left transparent.
   */
  renderChar(canvas: Canvas, x: number, y: number, ch: string, color: PixelColor): void {
    var code = ch.charCodeAt(0);
    if (code < 0x20 || code > 0x7E) return;
    // Delegate to Canvas.drawGlyph — color converted once for all 64 pixels
    canvas.drawGlyph(x, y, FONT_DATA_8x8, (code - 0x20) * 8, color);
  }
}

export const defaultFont = new BitmapFont();

// ── Canvas ─────────────────────────────────────────────────────────────────

export class Canvas {
  readonly width:  number;
  readonly height: number;

  /** Flat BGRA pixel buffer.  Index = y * width + x. */
  private _buf: Uint32Array;

  /** Offset into the screen framebuffer (for sub-canvases). */
  private _fb_x: number;
  private _fb_y: number;
  private _is_screen: boolean;

  constructor(width: number, height: number, fb_x = 0, fb_y = 0, is_screen = false) {
    this.width      = width;
    this.height     = height;
    this._buf       = new Uint32Array(width * height);
    this._fb_x      = fb_x;
    this._fb_y      = fb_y;
    this._is_screen = is_screen;
    this._buf.fill(0xFF000000); // default black
  }

  // ── Primitive helpers ──────────────────────────────────────────────────

  /** Convert AARRGGBB → BGRA (little-endian framebuffer word) */
  private static _bgra(color: PixelColor): number {
    var a = (color >>> 24) & 0xFF;
    var r = (color >>> 16) & 0xFF;
    var g = (color >>>  8) & 0xFF;
    var b = (color >>>  0) & 0xFF;
    return (a << 24) | (r << 16) | (g << 8) | b;
  }

  // ── Pixel access ──────────────────────────────────────────────────────

  setPixel(x: number, y: number, color: PixelColor): void {
    if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;
    this._buf[y * this.width + x] = Canvas._bgra(color);
  }

  getPixel(x: number, y: number): PixelColor {
    if (x < 0 || x >= this.width || y < 0 || y >= this.height) return 0;
    var bgra = this._buf[y * this.width + x];
    var a = (bgra >>> 24) & 0xFF;
    var r = (bgra >>> 16) & 0xFF;
    var g = (bgra >>>  8) & 0xFF;
    var b = (bgra >>>  0) & 0xFF;
    return (a << 24) | (r << 16) | (g << 8) | b;
  }

  // ── Drawing primitives ────────────────────────────────────────────────

  clear(color: PixelColor = Colors.BLACK): void {
    this._buf.fill(Canvas._bgra(color));
  }

  fillRect(x: number, y: number, w: number, h: number, color: PixelColor): void {
    var c  = Canvas._bgra(color);
    var x1 = Math.max(x, 0);
    var y1 = Math.max(y, 0);
    var x2 = Math.min(x + w, this.width);
    var y2 = Math.min(y + h, this.height);
    var rowW = x2 - x1;
    if (rowW <= 0) return;
    // Use TypedArray.fill() per row — native bulk operation, far faster than
    // an explicit inner for-col loop which generates individual array writes.
    for (var row = y1; row < y2; row++) {
      var base = row * this.width + x1;
      this._buf.fill(c, base, base + rowW);
    }
  }

  drawRect(x: number, y: number, w: number, h: number, color: PixelColor): void {
    this.fillRect(x,         y,         w,  1, color);  // top
    this.fillRect(x,         y + h - 1, w,  1, color);  // bottom
    this.fillRect(x,         y,         1,  h, color);  // left
    this.fillRect(x + w - 1, y,         1,  h, color);  // right
  }

  drawLine(x0: number, y0: number, x1: number, y1: number, color: PixelColor): void {
    var dx = Math.abs(x1 - x0);
    var dy = Math.abs(y1 - y0);
    var sx = x0 < x1 ? 1 : -1;
    var sy = y0 < y1 ? 1 : -1;
    var err = dx - dy;
    for (;;) {
      this.setPixel(x0, y0, color);
      if (x0 === x1 && y0 === y1) break;
      var e2 = 2 * err;
      if (e2 > -dy) { err -= dy; x0 += sx; }
      if (e2 <  dx) { err += dx; y0 += sy; }
    }
  }

  drawText(x: number, y: number, text: string, color: PixelColor, font = defaultFont): void {
    var cx = x;
    for (var i = 0; i < text.length; i++) {
      var ch = text[i];
      if (ch === '\n') { y += font.charHeight; cx = x; continue; }
      font.renderChar(this, cx, y, ch, color);
      cx += font.charWidth;
    }
  }

  measureText(text: string, font = defaultFont): { width: number; height: number } {
    return font.measureText(text);
  }

  // ── Compositing ───────────────────────────────────────────────────────

  /**
   * Fast glyph renderer: converts `color` once then writes directly into
   * _buf — no per-pixel color conversion or bounds-check call overhead.
   * `data` is the font bitmap array; `base` is the byte offset for the glyph.
   */
  drawGlyph(x: number, y: number, data: Uint8Array, base: number, color: PixelColor): void {
    var bgraColor = Canvas._bgra(color);   // convert ONCE, not 64 times
    for (var row = 0; row < 8; row++) {
      var py = y + row;
      if (py < 0 || py >= this.height) continue;
      var byte = data[base + row];
      if (!byte) continue;                  // skip blank rows early
      var rowBase = py * this.width;
      for (var col = 0; col < 8; col++) {
        if (byte & (0x80 >> col)) {
          var px = x + col;
          if (px >= 0 && px < this.width) this._buf[rowBase + px] = bgraColor;
        }
      }
    }
  }

  // ── Compositing ───────────────────────────────────────────────────────

  blit(src: Canvas, sx: number, sy: number, dx: number, dy: number,
       w: number, h: number): void {
    // Use TypedArray.set() per-row instead of a per-pixel loop.
    // For a 800×550 window this is ~550 bulk copies vs ~440,000 individual assignments.
    for (var row = 0; row < h; row++) {
      var dstY = dy + row;
      if (dstY < 0 || dstY >= this.height) continue;
      // Clamp column range to destination bounds
      var colStart = dx < 0 ? -dx : 0;
      var colEnd   = (dx + w > this.width) ? (this.width - dx) : w;
      if (colStart >= colEnd) continue;
      var srcOff = (sy + row) * src.width + sx + colStart;
      var dstOff =       dstY * this.width     + dx + colStart;
      this._buf.set(src._buf.subarray(srcOff, srcOff + (colEnd - colStart)), dstOff);
    }
  }

  /**
   * Blit external pixel data (already in canvas-native 0xAARRGGBB format) directly
   * into this canvas using Uint32Array.set() per row — zero per-pixel overhead.
   * Used by the image renderer: BMP data decoded by decodeBMP() is already in the
   * correct format so no conversion is needed, just bulk memory copies.
   */
  blitPixelsDirect(src: Uint32Array, srcW: number, srcH: number,
                   dx: number, dy: number): void {
    var cols = Math.min(srcW, this.width  - dx);
    var rows = Math.min(srcH, this.height - dy);
    if (cols <= 0 || rows <= 0) return;
    for (var row = 0; row < rows; row++) {
      var dstY = dy + row;
      if (dstY < 0 || dstY >= this.height) continue;
      this._buf.set(
        src.subarray(row * srcW, row * srcW + cols),
        dstY * this.width + dx,
      );
    }
  }

  // ── Framebuffer output ────────────────────────────────────────────────

  /**
   * Double-buffer flip: send the entire canvas to the physical framebuffer.
   * For the screen canvas, blits at (0,0).
   * For sub-canvases, blits at the registered (fb_x, fb_y) offset.
   */
  flip(): void {
    // Zero-copy fast path: pass the Uint32Array's backing ArrayBuffer directly.
    // C side detects it via JS_GetArrayBuffer() and calls a single memcpy.
    (kernel.fbBlit as any)(this._buf.buffer, this._fb_x, this._fb_y, this.width, this.height);
  }

  /**
   * Partial update — blit a sub-region of this canvas to the framebuffer.
   * Builds a compact typed-array region copy (one pass) then hands off
   * its backing ArrayBuffer to C for a single memcpy.
   */
  flipRegion(x: number, y: number, w: number, h: number): void {
    var region = new Uint32Array(w * h);
    for (var row = 0; row < h; row++) {
      var srcOff = (y + row) * this.width + x;
      region.set(this._buf.subarray(srcOff, srcOff + w), row * w);
    }
    (kernel.fbBlit as any)(region.buffer, this._fb_x + x, this._fb_y + y, w, h);
  }

  /** Get raw Uint32Array buffer (BGRA) for compositing without allocation */
  getBuffer(): Uint32Array { return this._buf; }
}

/**
 * Create the main screen canvas backed by the framebuffer, or null if
 * no framebuffer was negotiated by GRUB.
 */
export function createScreenCanvas(): Canvas | null {
  var info = kernel.fbInfo();
  if (!info) return null;
  return new Canvas(info.width, info.height, 0, 0, true);
}
